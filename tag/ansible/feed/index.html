<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	>

<channel>
	<title>ansible &#8211; blog.kroy.io</title>
	<atom:link href="https://blog.kroy.io/tag/ansible/feed/" rel="self" type="application/rss+xml" />
	<link>https://blog.kroy.io/</link>
	<description>computers, tech, and whatever other random stuff crosses my mind.</description>
	<lastBuildDate>Mon, 07 Dec 2020 15:36:35 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.5.4</generator>

<image>
	<url>https://blog.kroy.io/wp-content/uploads/2020/04/cropped-android-chrome-512x512-3-32x32.png</url>
	<title>ansible &#8211; blog.kroy.io</title>
	<link>https://blog.kroy.io/</link>
	<width>32</width>
	<height>32</height>
</image> 
<site xmlns="com-wordpress:feed-additions:1">166765678</site>	<item>
		<title>ESXi to Libvirt, now with more Terraform.</title>
		<link>https://blog.kroy.io/2020/11/03/esxi-to-libvirt-now-with-more-terraform/?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=esxi-to-libvirt-now-with-more-terraform</link>
		
		<dc:creator><![CDATA[Kroy]]></dc:creator>
		<pubDate>Tue, 03 Nov 2020 14:59:57 +0000</pubDate>
				<category><![CDATA[Automation]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[Terraform]]></category>
		<category><![CDATA[Ubuntu]]></category>
		<category><![CDATA[Virtualization]]></category>
		<category><![CDATA[ansible]]></category>
		<category><![CDATA[kvm]]></category>
		<category><![CDATA[migration]]></category>
		<category><![CDATA[terraform]]></category>
		<category><![CDATA[vmware]]></category>
		<guid isPermaLink="false">https://blog.kroy.io/?p=894</guid>

					<description><![CDATA[Over the years, my homelab has expanded and contracted multiple times. As I am heavy into automation now and downsizing a bit, it was time to fully ditch VMWare. Introduction&#8230;]]></description>
										<content:encoded><![CDATA[
<p>Over the years, my homelab has expanded and contracted multiple times.  As I am heavy into automation now and downsizing a bit, it was time to fully ditch VMWare.</p>



<hr class="wp-block-separator"/>





<h2>Introduction</h2>



<p>For some reason, it seems I am never happy with my lab.  For years now, I&#8217;ve constantly tore it up, started from scratch, migrated, <a rel="noreferrer noopener" href="https://blog.kroy.io/2017/06/30/migrating-the-lab-back-to-esxi-after-a-proxmox-experiment/" data-type="post" data-id="23" target="_blank">migrated back</a>, and more.  Up until recently, I had ESXi, Proxmox, libvirt, and even some HyperV in another VM for testing.  All these systems played different roles, even if they are just for learning.</p>



<p>By far, I&#8217;ve been running ESXi+vCenter the longest, and it would be considered my &#8220;primary&#8221; cluster.  When you have multiple hosts, heavy networking with stuff like vDS, want HA (high availability), it&#8217;s hard to argue that the vSphere suite doesn&#8217;t automate it and make it somewhat painless. </p>



<p>But now things have changed. I&#8217;m looking to combine and contract my lab, and more tightly integrate LXD/C and automation. I decided it was time to complete the migration completely away from VMWare products, especially since I&#8217;ve already sold/powered down/eliminated 3 out of the original 5 hosts in my cluster.   </p>



<p>Don&#8217;t get me wrong, with VMUG, VMWare is great and affordable, but I&#8217;m more interested in automation now than I am with HA, so a single host or two with a ton of CPU and RAM is a better fit.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="169" src="https://blog.kroy.io/wp-content/uploads/2020/10/image-1024x169.png" alt="" class="wp-image-896" srcset="https://blog.kroy.io/wp-content/uploads/2020/10/image-1024x169.png 1024w, https://blog.kroy.io/wp-content/uploads/2020/10/image-300x49.png 300w, https://blog.kroy.io/wp-content/uploads/2020/10/image-768x127.png 768w, https://blog.kroy.io/wp-content/uploads/2020/10/image-1536x253.png 1536w, https://blog.kroy.io/wp-content/uploads/2020/10/image-2048x337.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>The fat host</figcaption></figure>



<h2>Automation</h2>



<p>Automation has always been something that has been near and dear to my heart.  Put quite frankly, manually installing VMs, configuring to my liking, realizing I messed something up and starting over, is absolutely not fun.  </p>



<p>I&#8217;ve also focused heavily on making all my VMs &#8220;pure compute&#8221;.  This means something like Ansible or Docker, with all data stored on an NFS share or iSCSI export. The end result is being able completely nuke a VM, hit a button, and have it back up and running exactly where it left off within a few minutes.  It also means you don&#8217;t need to back up individual VMs, just a few basic text files, the main NAS, etc.  I&#8217;ve talked about some pieces of how I accomplish this in an older post <a rel="noreferrer noopener" href="https://blog.kroy.io/2017/08/14/fully-embracing-docker/" data-type="post" data-id="25" target="_blank">here</a>.  I just now deploy a similar config with Ansible.</p>



<h3>Prior Automation</h3>



<p>I&#8217;ve actually done a lot of automation in the past. Chef, Salt, but my first serious implementation was Foreman + Puppet.</p>



<p>Does Foreman work?  Absolutely.  It gives you the ability to automatically create and deploy fresh VMs with PXE and Puppet.  Is Foreman nice to use?  Absolutely not.   It&#8217;s just an absolute disaster to set up and maintain.  And forget trying to upgrade even minor versions.  I was religious about regularly snapshotting and backing up that Foreman virtual machine because usually an upgrade would require me to completely start from scratch.</p>



<h3>Current Automation</h3>



<p>For at least a year now, my main automation has been a combination of Terraform and Ansible.  Terraform talked to the vCenter API and cloned &#8220;gold master&#8221; VMs, and Ansible configured them to my liking.  I also have MAAS integrated for deploying the bare metal hosts, but that&#8217;s beyond the scope of this post.</p>



<p>This really has been a great solution, but I dislike needing to use &#8220;gold master&#8221; VMs, since they are something that I have to go back and renew and update every once in a while.  And like mentioned, I&#8217;m really wanting to get away from VMWare completely.</p>



<p>So I killed one of my ESXi hosts, and fired up Ubuntu.</p>



<h2>The Hypervisor</h2>



<p>Since this post will probably end up getting pretty long and with lots of code examples, I don&#8217;t want to waste too much time on describing the host setup. But I&#8217;ll try and give the important pieces:</p>



<ul><li>Ubuntu 20.04 Server.  Why Ubuntu?  Mostly because the driver support isn&#8217;t horrible.  At the time of this writing, I tried 20.10, but the communication between 20.10 virtio guest tools and Terraform is broken.</li><li>Setting up SSH key auth.  If you are using virsh, virt-manager remotely, it&#8217;s easiest to use SSH to communicate with libvirt.  Also, I store all my terraform configs on my workstation and terraform and ansible communicates via SSH.</li><li>Installing libvirt and other important stuff .</li></ul>



<pre class="wp-block-code"><code>sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils</code></pre>



<ul><li>Installing Network Manager.  On my hypervisors, I trunk everything, so nmcli is just a WAAAAY easier method of configuring a bunch of bridges.  I&#8217;ve provided working examples of my configuration of the <code>/etc/NetworkManager/system-connections</code> directory in a <a rel="noreferrer noopener" href="https://github.com/kroy-the-rabbit/esxitolibvirt-blog/tree/master/nmcli-examples/system-connections" target="_blank">github repo</a>.<ul><li>Note that the main interface (the slave), the main bridge (vmbr0), and the VLAN5 bridge all have the MTU set to 9000.  I use VLAN5  as my storage network, and this setup allows me to easily pass a 9000 MTU link into a VM.</li><li>Installing Network Manager requires you to change netplan and re-configure your networking.  The changing of Netplan involves removing the existing <code>yaml</code> file, creating a new one that looks like<a rel="noreferrer noopener" href="https://raw.githubusercontent.com/kroy-the-rabbit/esxitolibvirt-blog/master/nmcli-examples/netplan.yml" target="_blank"> this example from github</a>, and doing a <code>sudo netplan apply</code>.</li></ul></li><li>Both my central ISO storage and main VM storage happen via NFS.  So with Ubuntu, first I need to  <code>sudo apt install nfs-common</code>, and then add them as storage pools.  <ul><li>Even on systems without selinux, libvirt enforces it.  So if you add a new storage pool and get weird errors like &#8220;permission denied&#8221;, adding <code>security_driver = "none"</code> to your <code>/etc/libvirt/qemu.conf</code> file and restarting libvirt is a quick fix, though probably not the best fix from a security perspective.</li></ul><ul><li>This is easiest done with <code>virt-manager</code> on your local PC, and then connecting via SSH to the libvirt host.  Then just add pools</li></ul></li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="https://blog.kroy.io/wp-content/uploads/2020/11/image.png" alt="" class="wp-image-902" width="373" height="323" srcset="https://blog.kroy.io/wp-content/uploads/2020/11/image.png 373w, https://blog.kroy.io/wp-content/uploads/2020/11/image-300x260.png 300w" sizes="(max-width: 373px) 100vw, 373px" /></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="489" height="493" src="https://blog.kroy.io/wp-content/uploads/2020/11/image-1.png" alt="" class="wp-image-903" srcset="https://blog.kroy.io/wp-content/uploads/2020/11/image-1.png 489w, https://blog.kroy.io/wp-content/uploads/2020/11/image-1-298x300.png 298w, https://blog.kroy.io/wp-content/uploads/2020/11/image-1-150x150.png 150w" sizes="(max-width: 489px) 100vw, 489px" /></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="470" height="477" src="https://blog.kroy.io/wp-content/uploads/2020/11/image-2.png" alt="" class="wp-image-904" srcset="https://blog.kroy.io/wp-content/uploads/2020/11/image-2.png 470w, https://blog.kroy.io/wp-content/uploads/2020/11/image-2-296x300.png 296w" sizes="(max-width: 470px) 100vw, 470px" /></figure></div>



<hr class="wp-block-separator"/>



<h2>Terraform/Grunt</h2>



<p>The two main tools I want to talk about here are <code>terraform</code> and <code>terragrunt</code>.  A layperson&#8217;s definition of <code>terraform</code> is to define &#8220;infrastructure as code&#8221;.  That means, instead of clicking buttons to make a VM, choosing the amount of RAM, etc, you define it in the terraform domain specific language or DSL outlined <a rel="noreferrer noopener" href="https://www.terraform.io/docs/configuration/syntax.html" target="_blank">here</a>.  With <code>terraform</code>, you create a directory and put text files in it that define resources.  </p>



<p>Of course that&#8217;s a pretty dry definition, so all the examples that follow will outline how all this fits together.</p>



<p><code>terragrunt</code> is just a minor wrapper to <code>terraform</code> that extends it in a few nice ways.  You can drop different projects in different folders and apply changes to all or none, plus have pre/post hooks to run things.  I&#8217;ll have examples of this as well.  </p>



<blockquote class="wp-block-quote"><p>It&#8217;s very important to note that ALLLL terraform is concerned with is state.  If something is out of state, it does its best to non-destructively move it, but that depends on the module you are using.  </p><p>Most of the time it&#8217;s just as happy to just delete everything and start over.   Plans and applies will inform/warn you, but it&#8217;s really easy to get cocky and purge some data.</p><p>Keep that in mind as you begin your terraform journey.</p></blockquote>



<p>All of this is just happening on my local Linux workstation.  As <code>terragrunt</code> and <code>terraform</code> are both just <code>Go</code> programs, that means to install them you just download and run.  </p>



<h3>Install Terraform</h3>



<p>With <code>terraform</code>, there were some MAJOR changes in the <code>.13</code> version, and that&#8217;s the version I&#8217;ll be using.  Something like this can be used to install it on Linux:</p>



<pre class="wp-block-code"><code>wget https://releases.hashicorp.com/terraform/0.13.5/terraform_0.13.5_linux_amd64.zip | unzip terraform_0.13.5_linux_amd64.zip  &amp;&amp; sudo mv terraform /usr/local/bin &amp;&amp; rm terraform_0.13.5_linux_amd64.zip </code></pre>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="184" src="https://blog.kroy.io/wp-content/uploads/2020/11/image-3-1024x184.png" alt="" class="wp-image-909" srcset="https://blog.kroy.io/wp-content/uploads/2020/11/image-3-1024x184.png 1024w, https://blog.kroy.io/wp-content/uploads/2020/11/image-3-300x54.png 300w, https://blog.kroy.io/wp-content/uploads/2020/11/image-3-768x138.png 768w, https://blog.kroy.io/wp-content/uploads/2020/11/image-3-1536x276.png 1536w, https://blog.kroy.io/wp-content/uploads/2020/11/image-3.png 1593w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>terraform install</figcaption></figure>



<p>Similar methodology can be used to install <code>terragrunt</code></p>



<h3>Basic Layout</h3>



<p>As mentioned, I&#8217;m doing all this on my Linux workstation.  This will later allow me to easily shove this all into a git repo, make available from anywhere, etc.</p>



<figure class="wp-block-pullquote alignleft"><blockquote><p>Note that I&#8217;m not trying to make a comprehensive terraform guide here.</p><p>So I probably won&#8217;t be touching much on stuff like .tfvars files, which act sort of like env files, and things will be overly verbose so as to demonstrate what I&#8217;m doing. </p><p>There are plenty of opportunities for code reuse and further templating. Also, you can lay things out however you like. There&#8217;s not really any specific rules on how things need to be mapped out</p></blockquote></figure>



<p></p>



<p>Lets look at the basic layout for my infra:</p>



<pre class="wp-block-code"><code>❯ terraformroot                               
├── diskimages
│   └── focal-server-cloudimg-amd64.img
├── terragrunt.hcl
└── vms
    └── terragrunt.hcl

3 directories, 3 files</code></pre>



<p>This layout leverages the best of terraform and terragrunt.  It allows me to separate out different types of resources (VMs, and in the future LXC and networking), and access them separately (with normal terraform), or globally (with terragrunt).</p>



<p>The base directory <code>terragrunt.hcl</code> file is just empty.  It&#8217;s just a placeholder to allow you to use terragrunt from that level, meaning everything below it, like in <code>vms</code> would work on a <code>terragrunt apply-all</code>.</p>



<p>I also have a <code>diskimages</code> directory with the Ubuntu 20.04 cloud-init enabled image, found <a href="https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img" data-type="URL" data-id="https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img">at this link</a>. You can download this from Ubuntu every time, but it&#8217;s much quicker to store a copy locally and just use that, plus you are being a better netizen.    </p>



<p>The <code>vms</code>directory <code>terragrunt.hcl</code> contains a &#8220;post hook&#8221;.  This updates my DNS via a script whenever VMs are added, updated, or deleted.  This is a file that you may or may not need and may want to remove or skip creating.</p>



<hr class="wp-block-separator"/>



<h3>Setting up a VM</h3>



<p>Let&#8217;s start by creating a simple VM.</p>



<p>The first layout we are working on ends up looking like this:</p>



<pre class="wp-block-code"><code>vms
├── terragrunt.hcl
└── testvm.lan.kroy.io
    ├── cloud_init.cfg
    ├── global.tf
    ├── network_config.cfg
    ├── terragrunt.hcl
    └── vm.tf

1 directory, 6 files</code></pre>



<p>Here I&#8217;ve created a directory named after the destination VM for organization, and put the files <code>main.tf</code> and <code>terragrunt.hcl</code> in it.</p>



<p>You can name the actual terraform files whatever you want as long as it ends with <code>.tf</code>, but they are processed in alphabetical order.  Usually this won&#8217;t make too much of a difference, but in some scenarios it can.</p>



<hr class="wp-block-separator"/>



<h4>The Config Files</h4>



<ul><li>The first file is the <code>global.tf</code>.  This defines some of the basic pieces of our resource.</li></ul>



<pre class="wp-block-code"><code> terraform {
    required_version = ">= 0.13"
    required_providers {
        libvirt = {
            source  = "dmacvicar/libvirt"
            version = "0.6.2"
        }
        mikrotik = {
          source = "ddelnano/mikrotik"
          version = "0.3.6"
        }
    }
}

# instance the providers

provider "libvirt" {
    uri = "qemu+ssh://kroy@jack.lan.kroy.io/system"
}

provider "mikrotik" {
    host = "crs354.lan.kroy.io:8728"
    username = "admin"
    password = ""
}

resource "libvirt_volume" "os_tmpl" {
  name = "focal_os_tmpl"
  pool = "VM"
  source = "file:///home/kroy/Documents/infra/terraform/libvirt/diskimages/focal-server-cloudimg-amd64.img"
  format = "qcow2"
}
</code></pre>



<p>Breaking this down:</p>



<ol><li>The <code>terraform</code> section describes the module versions I want to pull.  In this case, I&#8217;m pulling the <code>libvirt</code> and <code>mikrotik</code> modules.   The <code>mikrotik</code> module is used to automatically set a static DHCP lease on my CRS.  This versioning is a the major change in terraform .13 I mentioned earlier. </li><li>The <code>libvirt</code> &#8220;provider&#8221; section sets up the connection via ssh to the host running libvirt.  User <code>kroy</code> is in the libvirt group on the host.</li><li>The <code>mikrotik</code> provider section connects via the Mikrotik API to my switch that runs my DHCP.</li><li>The final block set up a template disk image using the cloud-init enabled image that was downloaded earlier.</li></ol>



<hr class="wp-block-separator"/>



<ul><li>The next file is the <code>cloud_init.cfg</code>.  This file runs some &#8220;initial setup&#8221; tasks in the new VM.</li></ul>



<pre class="wp-block-code"><code>#cloud-config
hostname: ${hostname}
fqdn: ${fqdn}
manage_etc_hosts: true
users:
  - name: root
    ssh-authorized-keys:
      - ${file("/home/kroy/.ssh/id_ed25519.pub")}
      - ${file("/home/kroy/Documents/infra/terraform/keys/id_ansible.pub")}
  - name: kroy
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: users, admin
    home: /home/kroy
    shell: /bin/bash
    lock_passwd: false
    ssh-authorized-keys:
      - ${file("/home/kroy/.ssh/id_ed25519.pub")}
      - ${file("/home/kroy/Documents/infra/terraform/keys/id_ansible.pub")}
# only cert auth via ssh (console access can still login)
ssh_pwauth: false
disable_root: false
chpasswd:
  list: |
     kroy:test
  expire: False
packages:
  - qemu-guest-agent

growpart:
  mode: auto
  devices: &#091;'/']
  ignore_growroot_disabled: false

runcmd:
  - &#091; systemctl, daemon-reload ]
  - &#091; systemctl, enable, qemu-guest-agent.service ]
  - &#091; systemctl, start, --no-block, qemu-guest-agent.service ]
</code></pre>



<p>If you&#8217;ve got any sort of familiarity with Linux, most of what happens in this file should be somewhat self-explanatory, even if you are unfamiliar with the layout and formatting. </p>



<ul><li>Set up hostname, fqdn from variables that will be set from <code>vm.tf</code>.</li><li>Make the <code>/etc/hosts</code> file match the proper config.</li><li>Setup ssh keys and a separate user.  Set the ssh keys to my local ssh keys and ansible keys on my workstation</li><li>Change the password on the <code>kroy</code> user</li><li>Install the QEMU Guest Agent.  This is what allows the host and the VM to communicate.</li><li>Grow the partition to the max size possible.  This makes it so you can easily create a 5GB or 500GB VM from your <code>vm.tf</code>.</li><li>Make sure the guest agent is running.  I was having an issue with it not autostarting, but this series of <code>runcmd</code> allows it to work.</li></ul>



<hr class="wp-block-separator"/>



<ul><li>The <code>network_config.cfg</code> file.  Somewhat self-documenting. There are other ways to do this, but I&#8217;ve found this is easiest for my setup:</li></ul>



<pre class="wp-block-code"><code>version: 2
ethernets:
  ens3:
     dhcp4: true</code></pre>



<p>This is just a standard <code>netplan</code> config that gets dropped on the new VM.</p>



<hr class="wp-block-separator"/>



<ul><li>The final piece is the <code>vm.tf</code>. As my naming here suggests, this is the actual config for the VM.</li></ul>



<pre class="wp-block-code"><code># variables that can be overriden
variable "hostname" { default = "bgp" }
variable "domain" { default = "lan.kroy.io" }
variable "memoryGB" { default = 2 }
variable "cpu" { default = 2 }
variable "network" { default = "vibr20" }
variable "disksizeGB" { default = 20 }



resource "libvirt_volume" "os_image" {
  name = "${var.hostname}-os_image"
  pool   = "VM"
  base_volume_id = libvirt_volume.os_tmpl.id
  size = var.disksizeGB * 1024 * 1024 * 1024
}

# Use CloudInit ISO to add ssh-key to the instance
resource "libvirt_cloudinit_disk" "commoninit" {
  name = "${var.hostname}-commoninit.iso"
  pool = "VM"
  user_data = data.template_file.user_data.rendered
  network_config = data.template_file.network_config.rendered
}


data "template_file" "user_data" {
  template = file("${path.module}/cloud_init.cfg")
  vars = {
    hostname = var.hostname
    fqdn = "${var.hostname}.${var.domain}"
  }
}

data "template_file" "network_config" {
  template = file("${path.module}/network_config.cfg")
}


# Create the machine
resource "libvirt_domain" "domain-vm" {
  qemu_agent = true
  name = "${var.hostname}.${var.domain}"
  memory = var.memoryGB * 1024
  vcpu = var.cpu
  cloudinit = libvirt_cloudinit_disk.commoninit.id

  disk {
       volume_id = libvirt_volume.os_image.id
  }
  network_interface {
       wait_for_lease = true
       bridge = var.network
  }

  graphics {
    type = "spice"
    listen_type = "address"
    autoport = "true"
  }
  provisioner "local-exec" {
    environment = {
        IP = join("",slice(&#091;for ip in flatten(libvirt_domain.domain-vm.*.network_interface.0.addresses) : ip if substr(ip,0,8) == "10.20.20"],0,1))
    }
    command = "ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i $IP, --key-file=~/Documents/infra/terraform/keys/id_ansible -u root ~/Documents/infra/terraform/ansible/docker/deploy-docker_ubuntu.yml"

  }

}


resource "mikrotik_dhcp_lease" "dhcp" {
  address = join("",slice(&#091;for ip in flatten(libvirt_domain.domain-vm.*.network_interface.0.addresses) : ip if substr(ip,0,8) == "10.20.20"],0,1))
  macaddress = upper(join("",libvirt_domain.domain-vm.*.network_interface.0.mac))
  comment = "${var.hostname}.${var.domain}"
  hostname = var.hostname
}

</code></pre>



<p>There&#8217;s obviously a lot going on here, but the short of it is I&#8217;ll be creating multiple resources.  A cloud-init &#8220;boot disk&#8221;, some templates for passing into the cloud-init disk, the actual VM, and the DHCP record on my Mikrotik, which will read the IP of the created VM, and turn it into a static DHCP lease.</p>



<ol><li>The first part of this config is just some variables.  As I create a new VM, assuming I just want a fairly basic VM, all I need to do is change some things here.  To create a new VM, this is all that needs to be changed.  Note that these can be stored in a <code>.tfvars</code> file too for further separation.</li><li>The first resource is the actual VM disk.  Note that the size is multipled by 1024*1024*1024 to translate the size from bytes to gigabytes, for ease of use.</li><li>The next resource and following templates resources pulls in the cloud-init and network configs to build a cloud init image for initial booting and setup. </li><li>The next resource defines the VM.  Most of it should be self-explanatory.  Things like making sure the guest agent is enabled, setting up the hostname and fqdn from the variables, vcpus, memory, disk.  When you want to use data from a different resource, the format is &#8220;resource_type.resource_name.id&#8221;.  So to later refer to this VM, you&#8217;d used <code>libvirt_domain.domain-vm.id</code>.<ol><li>We set up a spice console, important for connecting to it via something like <code>virt-manager</code>.</li><li>The <code>network_interface</code> resource here tells it to wait for a lease.  This is necessary since I want my Mikrotik resource below to be have access to the IP that the VM was issued via DHCP.  This saves me from having to hard-code IPs.</li><li>I have a <code>local-exec</code> provisioner here.  This is how I call Ansible to configure the VM.  In this case I&#8217;ll be setting this host up as one of my Docker VMs.  Note that I&#8217;m doing some severe hacky stuff to make sure I only grab the IP in the subnet that I want.  </li></ol></li><li>Finally, the Mikrotik resource. As mentioned a few times, this sets a static DHCP lease on my main DHCP server, using the same hacky IP pulling code as above.</li></ol>



<hr class="wp-block-separator"/>



<h4>Terraforming the Virtual Machine</h4>



<p>Now that all the resources and config are declared, it&#8217;s time to actually create the VM.</p>



<p>The first step is to <code>initialize</code> the terraform repo here.  This causes it to pull the required modules and prepare for deployment.</p>



<pre class="wp-block-code"><code>❯ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/template...
- Finding dmacvicar/libvirt versions matching "0.6.2"...
- Finding ddelnano/mikrotik versions matching "0.3.6"...
- Installing hashicorp/template v2.2.0...
- Installed hashicorp/template v2.2.0 (signed by HashiCorp)
- Installing dmacvicar/libvirt v0.6.2...
- Installed dmacvicar/libvirt v0.6.2 (unauthenticated)
- Installing ddelnano/mikrotik v0.3.6...
- Installed ddelnano/mikrotik v0.3.6 (self-signed, key ID DDBA1674AA3EA0EE)

Partner and community providers are signed by their developers.
If you'd like to know more about provider signing, you can read about it here:
https:&#47;&#47;www.terraform.io/docs/plugins/signing.html

The following providers do not have any version constraints in configuration,
so the latest version was installed.

To prevent automatic upgrades to new major versions that may contain breaking
changes, we recommend adding version constraints in a required_providers block
in your configuration, with the constraint strings suggested below.

* hashicorp/template: version = "~> 2.2.0"

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.❯ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding dmacvicar/libvirt versions matching "0.6.2"...
- Installing dmacvicar/libvirt v0.6.2...
- Installed dmacvicar/libvirt v0.6.2 (unauthenticated)

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.</code></pre>



<p>Assuming you get a success message there and some green text, you can proceed to <code>plan</code> or even <code>apply</code>.</p>



<p><code>plan</code> shows you want it&#8217;s going to do.  <code>apply</code> will do it (with confirmation by default, but it can be overridden).</p>



<pre class="wp-block-code"><code>❯ terraform plan
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.

data.template_file.network_config: Refreshing state...
data.template_file.user_data: Refreshing state...

------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # libvirt_cloudinit_disk.commoninit will be created
  + resource "libvirt_cloudinit_disk" "commoninit" {
      + id             = (known after apply)
      + name           = "testvm-commoninit.iso"
      + network_config = &lt;&lt;~EOT
            version: 2
            ethernets:
              ens3:
                 dhcp4: true
        EOT
      + pool           = "VM"
      + user_data      = &lt;&lt;~EOT
            #cloud-config
            hostname: testvm
            fqdn: testvm.lan.kroy.io
            manage_etc_hosts: true
            users:
              - name: root
                ssh-authorized-keys:
                  - ssh-ed25519 key key1
                  - ssh-ed25519 key ansible
            
              - name: kroy
                sudo: ALL=(ALL) NOPASSWD:ALL
                groups: users, admin
                home: /home/kroy
                shell: /bin/bash
                lock_passwd: false
                ssh-authorized-keys:
                  - ssh-ed25519 key key1
                  - ssh-ed25519 key ansible
            
            # only cert auth via ssh (console access can still login)
            ssh_pwauth: false
            disable_root: false
            chpasswd:
              list: |
                 kroy:test
              expire: False
            packages:
              - qemu-guest-agent
            
            growpart:
              mode: auto
              devices: &#091;'/']
              ignore_growroot_disabled: false
            
            runcmd:
              - &#091; systemctl, daemon-reload ]
              - &#091; systemctl, enable, qemu-guest-agent.service ]
              - &#091; systemctl, start, --no-block, qemu-guest-agent.service ]
        EOT
    }

  # libvirt_domain.domain-vm will be created
  + resource "libvirt_domain" "domain-vm" {
      + arch        = (known after apply)
      + cloudinit   = (known after apply)
      + disk        = &#091;
          + {
              + block_device = null
              + file         = null
              + scsi         = null
              + url          = null
              + volume_id    = (known after apply)
              + wwn          = null
            },
        ]
      + emulator    = (known after apply)
      + fw_cfg_name = "opt/com.coreos/config"
      + id          = (known after apply)
      + machine     = (known after apply)
      + memory      = 2048
      + name        = "testvm.lan.kroy.io"
      + qemu_agent  = true
      + running     = true
      + vcpu        = 2

      + graphics {
          + autoport       = true
          + listen_address = "127.0.0.1"
          + listen_type    = "address"
          + type           = "spice"
        }

      + network_interface {
          + addresses      = (known after apply)
          + bridge         = "vibr20"
          + hostname       = (known after apply)
          + mac            = (known after apply)
          + network_id     = (known after apply)
          + network_name   = (known after apply)
          + wait_for_lease = true
        }
    }

  # libvirt_volume.os_image will be created
  + resource "libvirt_volume" "os_image" {
      + base_volume_id = (known after apply)
      + format         = (known after apply)
      + id             = (known after apply)
      + name           = "testvm-os_image"
      + pool           = "VM"
      + size           = 21474836480
    }

  # libvirt_volume.os_tmpl will be created
  + resource "libvirt_volume" "os_tmpl" {
      + format = "qcow2"
      + id     = (known after apply)
      + name   = "focal_os_tmpl"
      + pool   = "VM"
      + size   = (known after apply)
      + source = "file:///home/kroy/Documents/infra/terraform/libvirt/diskimages/focal-server-cloudimg-amd64.img"
    }

  # mikrotik_dhcp_lease.dhcp will be created
  + resource "mikrotik_dhcp_lease" "dhcp" {
      + address    = (known after apply)
      + blocked    = "false"
      + comment    = "testvm.lan.kroy.io"
      + dynamic    = false
      + hostname   = "testvm"
      + id         = (known after apply)
      + macaddress = (known after apply)
    }

Plan: 5 to add, 0 to change, 0 to destroy.

------------------------------------------------------------------------

Note: You didn't specify an "-out" parameter to save this plan, so Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.
</code></pre>



<p>Note the bottom line where is says it&#8217;s going to add 5, change 0, destroy 0.  </p>



<p>Keep remembering that all terraform is concerned with is state.  So it will happily delete and nuke everything to get it to make the state that you want.  So if a <code>plan</code> or <code>apply</code> says it&#8217;s going to delete a bunch of stuff and that&#8217;s not what you wanted, escape now!</p>



<p>Finally, <code>terraform apply</code> looks much like the plan above, and adds a few extra lines to confirm the operation (if you haven&#8217;t passed the option to skip it).</p>



<pre class="wp-block-code"><code>Plan: 5 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

...

Apply complete! Resources: 5 added, 0 changed, 0 destroyed
</code></pre>



<p>This should hopefully complete without error, and if you do a <code>virsh list</code> on the libvirt host, you&#8217;ll see something like:</p>



<pre class="wp-block-code"><code># virsh list 
 Id   Name                 State
------------------------------------
 1    testvm.lan.kroy.io   running
</code></pre>



<p>In my <code>terraform apply</code> output, I have <code>libvirt_domain.domain-vm (local-exec): ok: [10.20.20.79]</code>, which means I should be able to ssh there</p>



<pre class="wp-block-code"><code>❯ ssh kroy@10.20.20.79
Warning: Permanently added '10.20.20.79' (ECDSA) to the list of known hosts.
Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-51-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Mon Nov  2 17:55:54 UTC 2020

  System load:              0.0
  Usage of /:               11.0% of 19.21GB
  Memory usage:             15%
  Swap usage:               0%
  Processes:                121
  Users logged in:          0
  IPv4 address for docker0: 172.17.0.1
  IPv4 address for ens3:    10.20.20.79
 

41 updates can be installed immediately.
15 of these updates are security updates.
To see these additional updates run: apt list --upgradable



The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

To run a command as administrator (user "root"), use "sudo &lt;command>".
See "man sudo_root" for details.

kroy@testvm:~$</code></pre>



<p>SUCCESS!</p>



<hr class="wp-block-separator"/>



<h3>Terragrunt</h3>



<p>Even though we&#8217;ve only got a single resource so far, I want to touch on what <code>terragrunt</code> accomplishes for you.  </p>



<p>Terraform only works on single directories.  So say I wanted to add a second VM.  </p>



<p>I would do something like:</p>



<pre class="wp-block-code"><code>cd terraformroot
cp -pr vms/testvm.lan.kroy.io vms/doubletest.lan.kroy.io
rm vms/doubletest.lan.kroy.io/terraform.tfstate*
sed -i -e 's/testvm/doubletest/' vms/doubletest.lan.kroy.io/vm.tf</code></pre>



<p>Hopefully that is mostly self-explanatory:</p>



<ul><li>Change into our terraform directory.</li><li>Copying the existing config to a new VM directory.</li><li>Remove all the old terraform state files.  This is <em>VERY</em> important if you are going to be using terraform like this.  This is basically the main &#8220;database&#8221; for terraform and if you want to create a new resource, you don&#8217;t want the old database in the new resource directory.</li><li>A not-so-fancy one-liner to change the hostname of the new VM.</li></ul>



<p>Now you would have a few options to determine how you want to apply this configuration:</p>



<ol><li>Switch to <code>terraformroot/vms/doubletest.lan.kroy.io</code>, do a <code>terraform apply</code>.   This would only apply the state for this VM.</li><li>Switch to <code>terraformroot/vms</code>, do a <code>terragrunt apply-all</code>.  This would apply the state for <code>testvm.lan.kroy.io </code> and <code>doubletest.lan.kroy.io</code>.</li><li>Switch to <code>terraformroot</code>, and again, <code>terragrunt apply-all</code>.  This would apply the state for all resources under <code>vms</code>, and any future projects, like networking configs, LXC, etc.</li></ol>



<p>In all that, you can also do <code>plan-all</code> on terragrunt to see what it&#8217;s going to change.</p>



<p>In the directory for these VMs resources, I&#8217;ve got a <code>terragrunt.hcl</code>.  The contents of this are simply:</p>



<pre class="wp-block-code"><code>include {
  path = find_in_parent_folders()
}</code></pre>



<p>This says &#8220;look in any parent folders, and execute the actions of their <code>terragrunt.hcl</code>.&#8221;</p>



<p>This is powerful because you can have specific actions for just the <code>vms</code> directory or everything. That&#8217;s why the content of my <code>terragrunt.hcl</code> in the <code>vms</code> directory contains:</p>



<pre class="wp-block-code"><code>terraform {
  after_hook "after_hook" {
    commands     = &#091;"apply"]
    execute      = &#091;"/bin/bash","/home/kroy/Documents/infra/terraform/updatedns.sh"]
    run_on_error = true
  }
}
</code></pre>



<p>As is implied, this runs after you type <code>terragrunt apply</code> or <code>apply-all</code>. </p>



<p>Being in the <code>vms</code> sub-directory, when would this run?</p>



<ol><li>In the individual VM resource directory due to the <code>find_in_parent_folders</code> when you run terragrunt with apply or apply-all.</li><li>In the <code>vms</code> sub-directory when running apply all. You can&#8217;t run apply because that only looks in the current directory.</li><li>In the main <code>terraformroot</code> directory.    </li></ol>



<p>So running a <code>terragrunt apply-all</code> in the <code>vms</code> directory:</p>



<pre class="wp-block-code"><code>&#091;terragrunt] 2020/11/02 12:13:11 Stack at /home/kroy/Desktop/esxitolibvirt-blog/terraform/vms:
  => Module /home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/doubletest.lan.kroy.io (excluded: false, dependencies: &#091;])
  => Module /home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/testvm.lan.kroy.io (excluded: false, dependencies: &#091;])
&#091;terragrunt] 2020/11/02 12:13:11 &#091;terragrunt]  Are you sure you want to run 'terragrunt apply' in each folder of the stack described above? (y/n) </code></pre>



<p>The output of this shows that the new VM was created (and the original VM was at least looked at), and my post-hook is run once:</p>



<pre class="wp-block-code"><code>Apply complete! Resources: 0 added, 1 changed, 0 destroyed.
&#091;terragrunt] &#091;/home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/testvm.lan.kroy.io] 2020/11/02 12:14:52 Detected 1 Hooks
&#091;terragrunt] &#091;/home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/testvm.lan.kroy.io] 2020/11/02 12:14:52 Executing hook: after_hook
&#091;terragrunt] &#091;/home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/testvm.lan.kroy.io] 2020/11/02 12:14:52 Running command: /bin/bash /home/kroy/Documents/infra/terraform/updatedns.sh
&#091;terragrunt] &#091;/home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/testvm.lan.kroy.io] 2020/11/02 12:14:52 Module /home/kroy/Desktop/esxitolibvirt-blog/terraform/vms/testvm.lan.kroy.io has finished successfully!</code></pre>



<hr class="wp-block-separator"/>



<h2>Conclusion</h2>



<p>Well, there you have it.   Is this the perfect layout?  Probably not.  Is there room for improvement?  Absolutely.</p>



<p>I have put up a git repo <a rel="noreferrer noopener" href="https://github.com/kroy-the-rabbit/esxitolibvirt-blog" data-type="URL" data-id="https://github.com/kroy-the-rabbit/esxitolibvirt-blog" target="_blank">HERE</a>, containing all of the examples from above.</p>



<p>Of course this is far from complete.  With this setup, all you have are fairly blank and basic VMs.  You&#8217;d want to hit them with Ansible or something to finish configuring them.  But that&#8217;s a post for another day.</p>



<p>Enjoy!</p>
]]></content:encoded>
					
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">894</post-id>	</item>
	</channel>
</rss>
